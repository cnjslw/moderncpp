# C1 新基础类型（C++11～C++20）
## 1.1 整数类型long long (C++11)
C++标准中定义，long long是一个至少为64位的整数类型。请注意这里的用词“至少”，也就说long long的实际长度可能大于64位。



## 1.2 新字符类型char16_t和char32_t
在C++11标准中添加两种新的字符类型char16_t和char32_t，它们分别用来对应Unicode字符集的UTF-16和UTF-32两种编码方法。过去也没有一个针对UTF-16和UTF-32的字符类型。到了C++11，char16_t和char32_t的出现打破了这个尴尬的局面。除此之外，C++11标准还为3种编码提供了新前缀用于声明3种编码字符和字符串的字面量，它们分别是UTF-8的前缀u8、UTF-16的前缀u和UTF-32的前缀U
### 新字符串连接
如果两个字符串字面量具有相同的前缀，则生成的连接字符串字面量也具有该前缀；
### 对新字符类型的支持
随着新字符类型加入C++11标准，相应的库函数也加入进来。C11在中增加了4个字符的转换函数

<br>

# C2 内嵌和嵌套命名空间（C++11~C++20）
C++11标准增强了命名空间的特性，提出了内联命名空间的概念。内联命名空间能够把空间内函数和类型导出到父命名空间中，这样即使不指定子命名空间也可以使用其空间内的函数和类型


<br>

# C3 auto占位符（C++11 ~ C++17）
## 重新定义的auto关键字
C++11标准赋予了auto新的含义：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符
1.auto声明多个变量时，编译器从左向右推导，最左边为auto的具体类型
2.当使用条件表达式初始化auto声明的变量时，编译器总是使用表达能力更强的类型
3.auto声明非静态成员变量,C++11静态成员变量是可以用auto声明并且初始化的,不过前提是auto必须使用const限定符;C++17中不再需要const限定符
4.按照C++20之前的标准，无法在函数形参列表中使用auto声明形参（注意，在C++14中，auto可以为lambda表达式声明形参）

## 推导规则
1.按值初始化，忽略cv限定
2.目标对象如果是引用，则引用属性会被忽略
3.使用auto和万能引用声明变量时，对于左值会将auto推导为引用类型
4.目标对象是一个数组或者函数，则auto会被推导为对应的指针类型
5.当auto关键字与列表初始化组合时，这里的规则有新老两个版本（C++17标准）
5.1)直接使用列表初始化，列表中必须为单元素
5.2)用等号加列表初始化，列表中可以包含单个或者多个元素,auto类型被推导为`std::initializer_list<T>`

## 什么时候使用auto
1．当一眼就能看出声明变量的初始化类型的时候可以使用auto
2．对于复杂的类型，例如lambda表达式、bind等直接使用auto

## 返回类型推导
多重返回值，那么需要保证返回值类型是相同

## lambda表达式中使用auto类型推导
C++14标准中我们还可以把auto写到lambda表达式的形参中

## 非类型模板形参占位符（C++17）
C++17标准对auto关键字又一次进行了扩展，使它可以作为非类型模板形参的占位符。当然，我们必须保证推导出来的类型是可以用作模板形参的，否则无法通过编译