# C1 新基础类型（C++11～C++20）
## 1.1 整数类型long long (C++11)
C++标准中定义，long long是一个至少为64位的整数类型。请注意这里的用词“至少”，也就说long long的实际长度可能大于64位。



## 1.2 新字符类型char16_t和char32_t
在C++11标准中添加两种新的字符类型char16_t和char32_t，它们分别用来对应Unicode字符集的UTF-16和UTF-32两种编码方法。过去也没有一个针对UTF-16和UTF-32的字符类型。到了C++11，char16_t和char32_t的出现打破了这个尴尬的局面。除此之外，C++11标准还为3种编码提供了新前缀用于声明3种编码字符和字符串的字面量，它们分别是UTF-8的前缀u8、UTF-16的前缀u和UTF-32的前缀U
### 新字符串连接
如果两个字符串字面量具有相同的前缀，则生成的连接字符串字面量也具有该前缀；
### 对新字符类型的支持
随着新字符类型加入C++11标准，相应的库函数也加入进来。C11在中增加了4个字符的转换函数

<br>

# C2 内嵌和嵌套命名空间（C++11~C++20）
C++11标准增强了命名空间的特性，提出了内联命名空间的概念。内联命名空间能够把空间内函数和类型导出到父命名空间中，这样即使不指定子命名空间也可以使用其空间内的函数和类型


<br>

# C3 auto占位符（C++11 ~ C++17）
## 重新定义的auto关键字
C++11标准赋予了auto新的含义：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符
1.auto声明多个变量时，编译器从左向右推导，最左边为auto的具体类型
2.当使用条件表达式初始化auto声明的变量时，编译器总是使用表达能力更强的类型
3.auto声明非静态成员变量,C++11静态成员变量是可以用auto声明并且初始化的,不过前提是auto必须使用const限定符;C++17中不再需要const限定符
4.按照C++20之前的标准，无法在函数形参列表中使用auto声明形参（注意，在C++14中，auto可以为lambda表达式声明形参）

## 推导规则
1.按值初始化，忽略cv限定
2.目标对象如果是引用，则引用属性会被忽略
3.使用auto和万能引用声明变量时，对于左值会将auto推导为引用类型
4.目标对象是一个数组或者函数，则auto会被推导为对应的指针类型
5.当auto关键字与列表初始化组合时，这里的规则有新老两个版本（C++17标准）
5.1)直接使用列表初始化，列表中必须为单元素
5.2)用等号加列表初始化，列表中可以包含单个或者多个元素,auto类型被推导为`std::initializer_list<T>`

## 什么时候使用auto
1．当一眼就能看出声明变量的初始化类型的时候可以使用auto
2．对于复杂的类型，例如lambda表达式、bind等直接使用auto

## 返回类型推导(C++14)
多重返回值，那么需要保证返回值类型是相同

## lambda表达式中使用auto类型推导
C++14标准中我们还可以把auto写到lambda表达式的形参中

## 非类型模板形参占位符（C++17）
C++17标准对auto关键字又一次进行了扩展，使它可以作为非类型模板形参的占位符。当然，我们必须保证推导出来的类型是可以用作模板形参的，否则无法通过编译

<br>

# C4 decltype说明符（C++11-C++17）
## typeof和typeid

1. C++11之前，GCC的扩展支持typeof的运算符，通过该运算符可以操作数的具体类型

2. C++标准也提供了typeid运算符获取与目标操作数类型相关的信息，获取的类型信息会包含在一个类型为std::type_info的对象里，可以通过成员函数name获取类型名
- typeid的返回值是一个左值，且其生命周期一直被扩展到程序生命周期结束
- typeid返回的std::type_info删除了复制构造函数，若想保存std::type_info，只能获取其引用或者指针
- typeid的返回值总是忽略类型的 cv 限定符，也就是typeid(const T)== typeid(T))


## 使用decltype说明符
C++11 引入decltype说明符，使用decltype说明符可以获取对象或者表达式的类型
C++11 可以利用decltype解决auto无法推断返回值类型的问题（利用decltype和尾置返回类型），但是C++14中auto已经支持auto推导返回值类型了，但是C++14中，auto又会自动忽略引用属性，这时，利用decltype和尾置返回类型可以保留引用属性

## 推导规则
decltype(e)
1. e是未加括号的标识符表达式或者未加括号的类成员访问，则推导出的类型是e的类型T，但是如果不存在该类型或者是重载函数，则无法推导
2. e是函数调用或者仿函数调用，则为其返回值类型
3. e是T类型的左值，推导为T&
4. e是T类型的将亡值，推导为T&&
5. 除了以上情况，都是T

## cv限定都的推导
通常情况下，decltype(e)所推导的类型会同步e的cv限定符，但是还有其他情况，当e是未加括号的成员变量时，父对象表达式的cv限定符会被忽略，不能同步到推导结果


## decltype(auto) (C++14)
用decltype的推导表达式规则来推导auto,另外需要注意的是，decltype(auto)必须单
独声明，也就是它不能结合指针、引用以及cv限定符

## decltype(auto)作为非类型模板形参占位符（C++17）
与auto一样，在C++17标准中decltype(auto)也能作为非类型模板形参的占位符

## 总结
很大程度上加强了C++的泛型能力

<br>

# C5 函数返回类型后置（C++11）
C++11标准中的函数返回类型后置语法，通过这种方法可以让返回复杂类型的函数声明更加清晰易读。在无法使用C++14以及更新标准的情况下，通过返回类型后置语法来推导函数模板的返回类型无疑是最便捷的方法

# C6 右值引用（C++11 C++17 C++20）
## 右值与左值引用
用等号左右来区别左右值简单，但是有时无法正确断定
在C++中所谓的左值一般是指一个指向特定内存的具有名称的值（具名对象），有一个相对稳定的内存地址，并且有一段较长的生命周期
右值则是不指向稳定内存地址的匿名值（不具名对象），它的生命周期很短，通常是暂时性的
基于这一特征，我们可以用取地址符&来判断左值和右值，能取到内存地址的值为左值，否则为右值
但是有些情况，仍然要具体讨论，补充通常字面量是右值，但是字符串字面量除外

## 左值引用
常量左值引用可以绑定右值

## 右值引用
右值引用的特点之一是可以延长右值的生命周期

## 将亡值
将亡值是指表达式的值即将被移动或者转移所有权，这意味着该值不再有用，并且可以被销毁或重用。将亡值通常出现在右值引用类型的函数参数、返回语句和std::move()等函数中。
产生将亡值得两种情况：
第一种是使用类型转换将泛左值转换为该类型的右值引用
第二种在C++17标准中引入，我们称它为临时量实质化，指的是纯右值转换到临时对象的过程。每当纯右值出现在一个需要泛左值的地方时，临时量实质化都会发生，也就是说都会创建一个临时对象并且使用纯右值对其进行初始化

## 将左值转换为右值
1. std::move()
2. static_cast<Typeinfo&&>

## 万能引用和引用折叠
只要有左值引用参与进来，最后推导的结果就是一个左值引用
只有实际类型是一个非引用类型或者右值引用类型时，最后推导出来的才是一个右值引用
利用这样得特点,可以使用万能引用：T&& / auto&& 
 
 ## 完美转发
 万能引用最典型的用途被称为完美转发
 